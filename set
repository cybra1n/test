# * SPS Group
# *
# * OpenWay Way4 dedicated JRE 1.8.271
# *		
# * Author:			A741489
# * Creation date:	2020.11.16
# * Changed by:		
# * Change date:	
# * Change reason:	
# **************************************************************************************************
# * Usage:
# * _SIX_Setup_Package.ps1 { install | remove | check | reinstall* | repair* } [-f]* [-l LogFile]*
# * _SIX_Setup_Package.ps1 { info | summary* | help }
# * _SIX_Setup_Package.ps1 exportxml Output-Filename
# * (* not implemented yet)
# **************************************************************************************************
$VERSION = '0.20120808+.0' # version of this script


# **************************************************************************************************
# * package settings:
function Get-PackageConfiguration {
if ($global:ExternalConfiguration.Package) { $global:Package = $global:ExternalConfiguration.Package } else {
$global:Package = @{
	Vendor =		"OpenWay";			# e.g. "Adobe" (mandatory)
	Product =		"Way4 Java";		# e.g. "Reader" (mandatory)
	Version =		"1.8.271";		# e.g. "10" (mandatory)
	#Architecture =	"x64";	# "x86" or "x64" (optional)
	Release =		"001";		# e.g. "001" (mandatory)
	#LogFile =		"<LogFile>";		# alternative LogFile - this will override $OS["LogFile"];
										#  but parameter -L will override this again (optional)
	#IDOverride =	"<SpecialID>";		# overrides the autogenerated ID (Vendor_Product_Version[_Architecture]_Release)
										#  (optional)
	#Reboot = 		$true				# Enforce reboot after installation process
										#  (in real this script does never do a reboot -
										#   instead it returns the errorcode 3010 at its end)
}}}
# **************************************************************************************************


# **************************************************************************************************
# * organization settings:
function Get-OrganizationConfiguration {
if ($global:ExternalConfiguration.Organization) { $global:Organization = $global:ExternalConfiguration.Organization } else {
$global:Organization = @{
	Name = 'SPS';							# the name of your organization (mandatory)
	Mail = 'client-support@six-payment-services.com';	# servicedesk/hotline email adress of your organization (mandatory for ARP)
	ServiceTelephone = '+43 1 71701 - 4300';				# servicedesk/hotline telephon number of your organization (mandatory for ARP)
	Tag = 'SPS';							# a short tag of your organization name (mandatory)
}}}
# **************************************************************************************************


# **************************************************************************************************
# * operating system presets
function Get-OSConfiguration {
if ($global:ExternalConfiguration.OS) { $global:OS = $global:ExternalConfiguration.OS } else {
$global:OS = @{
	LogFile = "${env:LocalLogPath}\" + $Package["ID"] + ".log"	# global definition for LogFile; but parameter -L will override this
	MSIExecDefaultParameters = @("/qn", "REBOOT=ReallySuppress", "ALLUSERS=1")	# default arguments for msiexec
}}}
# **************************************************************************************************

# **************************************************************************************************
# * setup definition
function Get-SetupJobs {
if ($global:ExternalConfiguration.Setup) { $global:Setup = $global:ExternalConfiguration.Setup } else {
$Setup = @(); # do not touch this!

# install : kill process first (if any)
$Setup += @{
	Type = "exe";
	Name = "taskkill.exe";
	Parameters = @("/F /Im way4manager.exe /T");
	Path = "" + $CommonDirs["System32"] + "";
	AcceptExitCodes = @(128);
}

if( -not (test-Path("${env:ProgramFiles(x86)}\OpenWay"))){
	$Setup += @{
		Type = "ps";
		Name = "New-Item";
		Parameters = @("-ItemType", "directory", "-Path","`"${env:ProgramFiles(x86)}\OpenWay`"");
	}
}
$Setup += @{
	Type = "ps";
	UninstallName = "Remove-Item-IfEmpty";
	UninstallParameters = @(
		"-Path", "`"${env:ProgramFiles(x86)}\OpenWay`""
	);
	UninstallAcceptExitCodes = 1;
}

$Setup += @{
	Type = "exe";
	Name = "7z.exe";
	Parameters = @(
		"x java.zip",
		"-o`"C:\Program Files (x86)\OpenWay`"",
		"-y");
	Path = $CommonDirs["ProgramFiles64"] + "\7-Zip";
	WindowStyle = "Hidden";
	AcceptExitCodes = 1; # 1 is warning, not a critical error
}
$Setup += @{
	Type = "ps";
	UninstallName = "Remove-Item";
	UninstallParameters = @(
		"-Path", "`"${env:ProgramFiles(x86)}\OpenWay\Java`"",
		"-Recurse","-force");
	UninstallAcceptExitCodes = 1;
}

# uninstall : kill process first (if any)
$Setup += @{
	Type = "exe";
	UninstallName = "taskkill.exe";
	UninstallParameters = @("/F /Im way4manager.exe /T");
	UninstallPath = "" + $CommonDirs["System32"] + "";
	UninstallAcceptExitCodes = @(128);
}

# Last action: register installation:
$Setup += @{
	Type = "reg";
	Path = "HKLM:\Software\_SW-Delivery\" + $Package["ID"];
	Value = "InstallDate";
	Data = (get-date -Format "yyyy-MM-dd HH:mm:ss zz").ToString();
	ValueType = "String";
}

# --------------------------------------------------------------------------------------------------
# * Examples and documentation for setup definition
# * please only copy from examples instead of modifying them - so later revisitors have a chance to get them...

# * single setup block with all possible options:
#$Setup += @{
# * generic:
#	Type = "<TYPE>";				# type "msi", "msp", "msu", "exe", "ps" or "reg" (mandatory)
#	Architecture = "<Architecture>";# defines the architecture for which only this block have to proceed
#									#  (optional: Standard is unset, valid values: x86, x64)
#	Features = @("Feature1", ...);	# list of msi-features to be installed/removed (only msi, optional)
#	GUID = "<GUID>";				# msi-ProductCode (only msi, mandatory)
#	LogFile = "${env:LocalLogPath}\" + $Package["ID"] + ".setup.log";
#									# log file for directly supported setup types (msi/msp/msu, optional)
#	Properties = @("PROP1=x", ...);	# list of additional msi-properties (only msi, optional)
#	WindowStyle = "<Style>";		# state of the windows used for the process
#									# (only msi/msp/exe, optional: Standard "Normal",
#									#  valid values: Normal, Hidden, Minimized, Maximized)
#
# * installation:
#	Name = "<SETUP>";				# msi, msp, msu, executable or ps-command
#									#  (only msi/msp/msu/exe/ps, optional: installation action will be skipped if not set)
#	Parameters = @("<PAR1>", ...);	# parameters for executable or ps-command (only exe/ps, optional)
#	Path = "<PATH>";				# installation source path (only msi/msp/exe, optional: Standard $SourcePath) or
#									#  path to registry key (only reg, mandatory)
#	Transforms = "<MST>";			# msi-transforms file relative to Path (only msi/msp, optional)
#	AcceptExitCodes = @(0, 5, ...);	# list of accepted return codes at installation (optional)
#
# * uninstallation:
#	UninstallName = "<SETUP>";					# executable or ps-command
#												#  (only exe/ps, optional: uninstallation action will be skipped if not set)
#	UninstallParameters = @("<PAR1>", ...);		# parameters to executable or ps-command (only exe/ps, optional)
#	UninstallPath = "<PATH>";					# uninstallation source path (only exe, optional: Standard $SourcePath)
#	UninstallAcceptExitCodes = @(0, 5, ...);	# list of accepted return codes at uninstallation (optional)
#	DontRemove = $True;							# do not remove at uninstallation (optional, only msu)
#
# * ARP:
#	ARPID = "<Uninstall-ID in Registry>";	# key name of registry uninstall entry
#											#  (optional; but mandatory if any ARP setting is used)
#	ARPWow6432Node = $false;				# ARP entry below Wow6432Node? (optional, default $false, only on x64 OS)
#	ARPName = [String]$Package["Product","Version","Architecture"];		# ProductName (optional)
#	ARPPublisher = $Package["Vendor"];		# ProductVendor/ProductPublisher (optional)
#	ARPVersion = $Package["Version"];		# ProductVersion (optional)
#	ARPIcon = "${env:ProgramFiles}\Vendor\Product\program.exe,0";	# ARPPRODUCTICON (optional)
#	ARPUninstallString = "${env:ProgramFiles}\V\P\uninstall.exe";	# sets the uninstall command;
#											# if its neither given nor existent in registry, a messagebox command will be
#											# placed and all ARPNo* will be set to true (optional)
#	ARPContact = "IT-Servicedesk";			# ARPCONTACT (optional)
#	ARPComments = "Repackaging/Customization for " + $Organization["Name"];		# ARPCOMMENTS (optional)
#	ARPHelpLink = "mailto:" + $Organization["Mail"];		# ARPHELPLINK (optional)
#	ARPHelpTelephone = $Organization["ServiceTelephone"];	# ARPHELPTELEPHONE (optional)
#	ARPNoModify = $true;					# ARPNOMODIFY (optional)
#	ARPNoRemove = $false;					# ARPNOREMOVE (optional)
#	ARPNoRepair = $true;					# ARPNOREPAIR (optional)
#	ARPSystemComponent = $false;			# ARPSYSTEMCOMPONENT (optional)
#	RemoveARPURLUpdateInfo = $true;			# remove ARPURLUPDATEINFO  (optional)
#	UninstallARP = $false;					# remove whole ARP key at uninstallation (optional)
#
# * registry:
#	Value = "ProductName";		# registry value (only reg, mandatory)
#	Data = [String]$Package["Product","Version","Architecture"];	# registry data (only reg, mandatory)
#	ValueType = "String";		# registry data type (only reg, optional: Standard "String",
#								#  valid values: String, ExpandString, DWord, MultiString, QWord, Binary)
#
# * check installation:
#	CheckType = "<Type>"		# type of check: "file", "registry", "uninstall", or "execute" (optional)
#								#  description:
#								#   execute: test a exitcode of an script or binary
#								#   file: test a file existence, size, version or date
#								#   registry: test a registry key/value existence or data
#								#   uninstall: test a ARP entry existence or version
#	CheckCondition = "<COND>"	# condition for check (mandatory if CheckType is set)
#								#  description:
#								#   equals: equals CheckPaths data with CheckValue? (only for registry)
#								#   exitcode_{eq|lt|le|gt|ge}: is exitcode eq/lt/le/gt/ge CheckValue? (only for execute)
#								#   {c|m|a}date_{eq|lt|le|gt|ge}: is files creation/modification/access date eq/lt/le/gt/ge CheckValue? (only for file)
#								#   exists: does file/registry key/registry value/ARP entry in CheckPath exists? (only for file, registry and uninstall)
#								#   size_{eq|lt|le|gt|ge}: is file size eq/lt/le/gt/ge CheckValue? (only for file)
#								#   version_{eq|lt|le|gt|ge}: is file version/ARP entry version eq/lt/le/gt/ge CheckValue? (only for file and uninstall)
#	CheckPath = "<OBJECT>"		# object of the test: file path, registry key or value, executable path or ARP DisplayName
#	CheckValue = "<DATA>"		# data to test for: registry data, exitcode, date in ISO8601, size in bytes or version number
#}

# * MSI example with TRANSFORMS:
#$Setup += @{
#	Type = "msi";
#	Name = "setupA.msi";
#	Transforms = "setupA.mst";
#	GUID = "{11111111-1111-1111-1111-111111111111}";
#}

# * MSI example without TRANSFORMS:
#$Setup += @{
#	Type = "msi";
#	Name = "setupB.msi";
#	GUID = "{00000000-0000-0000-0000-000000000000}";
#}

# * MSP example:
#$Setup += @{
#	Type = "msp";
#	Name = "update.msp";
#}

# * MSU example:
#$Setup += @{
#	Type = "msu";
#	Name = "update.msu";
#	DontRemove = $False;
#}

# * Executable setup example with uninstallation from source directory:
#$Setup += @{
#	Type = "exe";
#	Name = "setupC.exe";
#	Parameters = @("/SILENT");
#	UninstallName = "setupC.exe";
#	UninstallParameters = @("/SILENT", "/REMOVE");
#}

# * Executable setup example with uninstallation from target directory:
#$Setup += @{
#	Type = "exe";
#	Name = "setupD.exe";
#	Parameters = @("/S", "/Q");
#	UninstallName = "uninstall.exe";
#	UninstallParameters = @("/S", "/Q", "/R");
#	UninstallPath = "${env:ProgramFiles(x86)}\Vendor\Product";
#}

# * PowerShell example:
#$Setup += @{
#	Type = "ps";
#	Name = "Copy-Item";
#	Parameters = @(
#		"-Path",		"`"${SourcePath}\CustomConfiguration`"",
#		"-Destination",	"`"${env:ProgramData}\Vendor\Product\Configuration`"",
#		"-Force",
#		"-Recurse"
#	);
#	UninstallName = "Remove-Item";
#	UninstallParameters = @(
#		"-Path",	"`"${env:ProgramData}\Vendor\Product\Configuration`"",
#		"-Force",
#		"-Recurse"
#	);
#}

# * PowerShell example to create shortcut:
#$Setup += @{
#	Type = "ps";
#	Name = "Create-Shortcut";
#	Parameters = @(
#		"-Path",				("`"" + $CommonDirs["ProgramsApplications"] + "\Notepad`""),# directory path to the shortcut (mandatory)
#		"-Name",				("`"Notepad Editor.lnk`""),						# filename of the shortcut (mandatory)
#		"-Target",				("`"" + $CommonDirs["SystemRoot"] + "\notepad.exe`""),	# target of the shortcut (mandatory)
#		"-Arguments",			("`"N:\my.txt`""),								# arguments to the target (optional)
#		"-Icon",				("`"" + $CommonDirs["System32_Current"] + "\shell32.dll,152`""),	# icon (optional)
#		"-WorkingDirectory",	("`"N:\`""),										# working directory of target (optional)
#		"-Description",			("`"A test shortcut.`""),							# description (optional)
#		"-HotKey",				("`"CTRL+ALT+N`"")								# hot key (optional)
#	);
#	UninstallName = "Remove-Item";
#	UninstallParameters = @(
#		"-Path",	("`"" + $CommonDirs["ProgramsApplications"] + "\Notepad\Notepad Editor.lnk`""),
#		"-Force"
#	);
#}

# * PowerShell example to remove empty directory or registry paths:
#$Setup += @{
#	Type = "ps";
#	Name = "Remove-Item-IfEmpty";
#	Parameters = @(
#		"-Path", "`"${env:ProgramData}\Vendor`""
#	);
#}

# * Registry example:
#$Setup += @{
#	Type = "reg";
#	Path = "HKLM:\Software\Classes\Installer\Products\aaaabbbbccccddddeeeeffff00001111";
#	Value = "ProductName";
#	Data = [String]$Package["Product","Version","Architecture"];
#	ValueType = "String";
#}

# * End of examples.
# --------------------------------------------------------------------------------------------------

$global:Setup = $Setup }}	# do not touch this!
# **************************************************************************************************





# **************************************************************************************************
# * do not touch anything below!
# **************************************************************************************************
if ($PSVersionTable.PSVersion.Major -lt 2) {
	"ERROR: This Script requires at least version 2.0 of the PowerShell!"
	"For more information and download visit: http://www.microsoft.com/powershell"
	exit 1
}
# * generic functions:
function Create-Shortcut {
	param (
		[Parameter(Mandatory=$true)][String]$Path,
		[Parameter(Mandatory=$true)][String]$Name,
		[Parameter(Mandatory=$true)][String]$Target,
		[String]$Arguments,
		[String]$Icon,
		[String]$WorkingDirectory,
		[String]$Description,
		[String]$HotKey
	)
	New-Item -type directory -path $Path -force | Out-Null
	$WShell = New-Object -comObject WScript.Shell
	$Shortcut = $WShell.CreateShortcut("$Path\$Name")
	$Shortcut.TargetPath = $Target
	if ($Arguments)			{ $Shortcut.Arguments = $Arguments }
	if ($Icon)				{ $Shortcut.IconLocation = $Icon }
	if ($WorkingDirectory)	{ $Shortcut.WorkingDirectory = $WorkingDirectory }
	if ($Description)		{ $Shortcut.Description = $Description }
	if ($HotKey)			{ $Shortcut.HotKey = $HotKey }
	$Shortcut.Save()
}
function Get-CommonShellFolder {
	param (
		[Parameter(Mandatory=$true)][String]$Identifier
	)
	Get-RegistryValue -Path "hklm:\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" -Value "$Identifier"
}
function Get-RegistryValue {
	param (
		[Parameter(Mandatory=$true)][String]$Path,
		[String]$Value
	)
	if (-not $Value) {
		$Value = split-Path -leaf $Path;
		$Path = split-Path -parent $Path;
	}
	Get-ItemProperty -Path "$Path" -name "$Value" -ErrorAction SilentlyContinue `
		| Select-Object -ExpandProperty "$Value" -ErrorAction SilentlyContinue
}
function hr { "-" * ($Host.UI.RawUI.MaxWindowSize.Width - 1) }
function Is-MSI-Installed {
	param (
		[Parameter(Mandatory=$true)][String]$ProductCode
	)
	Get-WmiObject -class "Win32_Product" | ForEach-Object {
		if ( $_.IdentifyingNumber.ToLower() -eq $ProductCode.ToLower() ) { return $true }
	}
	return $false
}
function title {
	param (
		[Parameter(Mandatory=$true)][String]$Title
	)
	hr; ">>> " + $Title + ":"; ""
}
function Remove-Item-IfEmpty {
	param (
		[Parameter(Mandatory=$true)][String]$Path
	)
	if (Test-Path "$Path") {
		if ( -not (get-childitem "$Path" -ErrorAction SilentlyContinue)) { Remove-Item "$Path" -Force }
		else { "Path `"$Path`" not empty - removing ignored." }
	}
	else { "Path `"$Path`" not found - removing ignored."	}
}
function Remove-RegistryValue {
	param (
		[Parameter(Mandatory=$true)][String]$Path,
		[String]$Value
	)
	if (-not $Value) {
		$Value = split-Path -leaf $Path;
		$Path = split-Path -parent $Path;
	}
	Remove-ItemProperty -Path "$Path" -Name "$Value" `
		-Force -ErrorAction SilentlyContinue | Out-Null
}
function Set-RegistryValue {
	param (
		[Parameter(Mandatory=$true)][String]$Path,
		[String]$Value,
		[Parameter(Mandatory=$true)][String]$Data,
		[String]$Type
	)
	if (-not $Value) {
		$Value = split-Path -leaf $Path;
		$Path = split-Path -parent $Path;
	}
	if (-not $Type) { $Type = 'String' }
	if ( -not (Test-Path "$Path") ) { New-Item -Path "$Path" -type directory -force | Out-Null }
	New-ItemProperty -Path "$Path" -Name "$Value" -Value "$Data" -Type $Type -Force | Out-Null
}
function Test-Setup {
	param (
		[Parameter(Mandatory=$true)]$SetupDefinition
	)

	if ( ("msi", "msp" -contains $SetupDefinition.Type.ToLower()) -and $SetupDefinition.GUID ) {
		if ( -not (Is-MSI-Installed -ProductCode $SetupDefinition.GUID) ) { return $false }
	}
	if ( $SetupDefinition.Name -and $SetupDefinition.CheckType -and $SetupDefinition.CheckCondition -and $SetupDefinition.CheckPath ) {
		switch ( $SetupDefinition.CheckType.ToLower() ) {
			"file" {
				if ( (Test-Path $SetupDefinition.CheckPath) ) {
					switch -regex ( $SetupDefinition.CheckCondition.ToLower() ) {
						"^exists$" {}
						"^(c|m|a)date_(eq|lt|le|gt|ge)$" {
							switch ( $SetupDefinition.CheckCondition.ToLower().Substring(0,1) ) {
								"c" { $filedate = Get-Date -UFormat %s -Date (Get-Item $SetupDefinition.CheckPath).CreationTime }
								"m" { $filedate = Get-Date -UFormat %s -Date (Get-Item $SetupDefinition.CheckPath).LastWriteTime }
								"a" { $filedate = Get-Date -UFormat %s -Date (Get-Item $SetupDefinition.CheckPath).LastAccessTime }
							}
							$condition = [String]$SetupDefinition.CheckCondition.ToLower().Split("_")[1]
							$checkvalue = Get-Date -UFormat %s -Date $SetupDefinition.CheckValue
							Invoke-Expression -Command "if ( -not ($filedate -$condition $checkvalue) ) { return $false }"
						}
						"^size_(eq|lt|le|gt|ge)$" {
							$filesize = (Get-Item $SetupDefinition.CheckPath).Length
							$condition = [String]$SetupDefinition.CheckCondition.ToLower().Split("_")[1]
							$checkvalue = $SetupDefinition.CheckValue
							Invoke-Expression -Command "if ( -not ($filesize -$condition $checkvalue) ) { return $false }"
						}
						"^version_(eq|lt|le|gt|ge)$" {
							$fileversion = (Get-Item $SetupDefinition.CheckPath).VersionInfo.FileVersion
							$condition = [String]$SetupDefinition.CheckCondition.ToLower().Split("_")[1]
							$checkvalue = $SetupDefinition.CheckValue
							Invoke-Expression -Command "if ( -not ([Version]$fileversion -$condition [Version]$checkvalue) ) { return $false }"
						}
						default { return 1024 }
					}
				}
				else { return $false }
			} # end of switch:file
			"registry" {
				switch ( $SetupDefinition.CheckCondition.ToLower() ) {
					"exists" {
						$Path = $SetupDefinition.CheckPath
						if ( -not (Get-ItemProperty -Path $Path -ErrorAction SilentlyContinue)) {
							$Value = split-Path -leaf $Path
							$Path = split-Path -parent $Path
							if ( -not (Get-ItemProperty -Path $Path -Name $Value -ErrorAction SilentlyContinue) ) { return $false }
						}
					}
					"equals" {
						if ( -not ((Get-RegistryValue -Path $SetupDefinition.CheckPath) -eq $SetupDefinition.CheckValue) ) { return $false }
					}
					default { return 1024 }
				}
			} # end of switch:registry
			"uninstall" {
				switch -regex ( $SetupDefinition.CheckCondition.ToLower() ) {
					"^exists$" {
						$found = $false
						ForEach ($SearchRegkey in @(
								"HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall",
								"HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall")
								) {
							ForEach ($SearchPath in (Get-ChildItem -Path $SearchRegkey -ErrorAction SilentlyContinue)) {
								if ((Get-RegistryValue -Path $SearchPath.PSPath -Value "DisplayName") -eq $SetupDefinition.CheckPath) {
									$found = $true
								}
							}
						}
						if ($found -eq $false) { return $false }
					}
					"^version_(eq|lt|le|gt|ge)$" {
						$found = $false
						$condition = [String]$SetupDefinition.CheckCondition.ToLower().Split("_")[1]
						$checkvalue = $SetupDefinition.CheckValue
						ForEach ($SearchRegkey in @(
								"HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall",
								"HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall")
								) {
							ForEach ($SearchPath in (Get-ChildItem -Path $SearchRegkey -ErrorAction SilentlyContinue)) {
								$foundversion = Get-RegistryValue -Path $SearchPath.PSPath -Value "DisplayVersion"
								Invoke-Expression -Command "if ( [Version]$foundversion -$condition [Version]$checkvalue ) {`$found = `$true}"
							}
						}
						if ($found -eq $false) { return $false }
					}
					default { return 1024 }
				}
			} # end of switch:uninstall
			"execute" {
				switch -regex ( $SetupDefinition.CheckCondition.ToLower() ) {
					"^exitcode_(eq|lt|le|gt|ge)$" {
						$executable = $SetupDefinition.CheckPath
						$condition = [String]$SetupDefinition.CheckCondition.ToLower().Split("_")[1]
						$checkvalue = $SetupDefinition.CheckValue
						$exitcode = (Start-Process -Wait -WindowStyle "Hidden" -Passthru -FilePath "$executable").ExitCode
						Invoke-Expression -Command "if ( -not ($exitcode -$condition $checkvalue) ) { return $false }"
					}
					default { return 1024 }
				}
			} # end of switch:execute
			default { return 1024}
		} # end of switch
		return $true
	} # end of if
}


# **************************************************************************************************
# * presets and other constants:
$global:ConfirmPreference = 'None'
$global:ErrorActionPreference = 'Stop'
$SetupLoopVariables = @(
	"Command", "Parameters", "GUID", "MSI", "MSU", "Path",
	"Value", "Data", "ValueType", "ARPRegPath",
	"CurrentExitCode", "CurrentExitMessage")
$SourcePath = split-Path -parent $MyInvocation.MyCommand.Definition
$ScriptName = split-Path -Leaf $MyInvocation.MyCommand.Definition
$ScriptConfigurationXML = $SourcePath + "\" + [System.IO.Path]::GetFileNameWithoutExtension($ScriptName) + ".xml"
Remove-Variable -Name ExternalConfiguration -Scope global -ErrorAction SilentlyContinue
if ( Test-Path -Path $ScriptConfigurationXML ) {
	$global:ExternalConfiguration = Import-Clixml -Path $ScriptConfigurationXML
}

Get-OrganizationConfiguration
Get-PackageConfiguration

# * generating Package-ID:
if ( $Package["IDOverride"] ) {	$global:Package["ID"] = $Package["IDOverride"]; }
else {
	$global:Package["ID"] = `
		( $Package["Vendor"] -replace "\s","" ) + "_" + `
		( $Package["Product"] -replace "\s","" ) + "_" + `
		$Package["Version"] + "_";
	if ( $Package["Architecture"] ) { $global:Package["ID"] += $Package["Architecture"] + "_"; }
	$global:Package["ID"] += $Package["Release"];
}

Get-OSConfiguration

if ($OS["LogFile"]) { $LogFile = $OS["LogFile"] }
if ($Package["LogFile"]) { $LogFile = $Package["LogFile"] }
if ( $LogFile ) {
	if ( -not (Test-Path (split-path -parent "$LogFile")) ) {
		New-Item -Path (split-path -parent "$LogFile") -type directory -force | Out-Null
	}
	Start-Transcript -Path "$LogFile" -Append -Force
}

# * refining $OS:
$global:OS += @{
	Architecture = (Get-WmiObject -Class Win32_OperatingSystem -ErrorAction SilentlyContinue).OSArchitecture;
		#FIXME: this won't work with <NT6 - see: http://msdn.microsoft.com/en-us/library/aa394239.aspx
	BuildVersion = (Get-WmiObject -Class Win32_OperatingSystem -ErrorAction SilentlyContinue).BuildNumber;
	CompleteVersion = (Get-WmiObject -Class Win32_OperatingSystem -ErrorAction SilentlyContinue).Version;
	CurrentUser = ${env:UserName};
	CurrentDomain = ${env:UserDNSDomain};
	Hostname = (Get-WmiObject -Class Win32_OperatingSystem -ErrorAction SilentlyContinue).CSName;
	LCID = (Get-WmiObject -Class Win32_OperatingSystem -ErrorAction SilentlyContinue).OSLanguage;
	MajorVersion = [Int32]((Get-WmiObject -Class Win32_OperatingSystem -ErrorAction SilentlyContinue).Version `
					| %{$_.split('.')[0]});
	MinorVersion = [Int32]((Get-WmiObject -Class Win32_OperatingSystem -ErrorAction SilentlyContinue).Version `
					| %{$_.split('.')[1]});
	Name = (Get-WmiObject -Class Win32_OperatingSystem -ErrorAction SilentlyContinue).Caption;
	PSVersion = [String]$PSVersionTable.PSVersion.Major + "." + [String]$PSVersionTable.PSVersion.Minor;
	RegisteredOrganization = (Get-WmiObject -Class Win32_OperatingSystem -ErrorAction SilentlyContinue).Organization;
	RegisteredUser = (Get-WmiObject -Class Win32_OperatingSystem -ErrorAction SilentlyContinue).RegisteredUser;
	SPMajorVersion = (Get-WmiObject -Class Win32_OperatingSystem -ErrorAction SilentlyContinue).ServicePackMajorVersion;
	SPMinorVersion = (Get-WmiObject -Class Win32_OperatingSystem -ErrorAction SilentlyContinue).ServicePackMinorVersion;
}
if ( $OS["Architecture"] -eq '64-bit' ) { $global:OS["Architecture"] = 'x64' }
else { $global:OS["Architecture"] = 'x86' }
if ([System.IntPtr]::Size -eq 4) { $global:OS["ArchitectureEnvironment"] = 'x86' }
else { $global:OS["ArchitectureEnvironment"] = 'x64' }
$global:OS["Version"] = [String]$OS["MajorVersion"] + '.' + [String]$OS["MinorVersion"];
$global:OS["Name"] += '[' + $OS["Architecture"] + ']';
if ( $OS["SPMajorVersion"] -gt 0 -or $OS["SPMinorVersion"] -gt 0 ) {
	$global:OS["SPVersion"] = [String]$OS["SPMajorVersion"] + '.' + [String]$OS["SPMinorVersion"];
	$global:OS["Name"] += ' (' + (Get-WmiObject -Class Win32_OperatingSystem).CSDVersion + ')';
}
if ( -not $OS["CurrentDomain"] ) { $global:OS["CurrentDomain"] = ${env:UserDomain} }

# * refining $CommonDirs:
$CommonDirs = @{
	AdministrativeTools =	(Get-CommonShellFolder "Common Administrative Tools");
	AppData =				(Get-CommonShellFolder "Common AppData");
	Desktop =				(Get-CommonShellFolder "Common Desktop");
	Documents =				(Get-CommonShellFolder "Common Documents");
	Music =					(Get-CommonShellFolder "CommonMusic");
	Pictures =				(Get-CommonShellFolder "CommonPictures");
	Programs =				(Get-CommonShellFolder "Common Programs");
	StartMenu =				(Get-CommonShellFolder "Common Start Menu");
	Startup =				(Get-CommonShellFolder "Common Startup");
	Templates =				(Get-CommonShellFolder "Common Templates");
	Video =					(Get-CommonShellFolder "CommonVideo");
	SystemDrive =			${env:SystemDrive};
	SystemRoot =			${env:SystemRoot};
	System32_Current =		${env:SystemRoot} + "\system32";
	HKLMSoftware_Current =	"hklm:\Software";
}
if ( $OS["ArchitectureEnvironment"] -eq 'x64' ) {
	$CommonDirs["ProgramFiles32"] = ${env:ProgramFiles(x86)}
	$CommonDirs["ProgramFiles64"] = ${env:ProgramFiles}
	$CommonDirs["System32"] = ${env:SystemRoot} + "\SysWOW64"
	$CommonDirs["System64"] = ${env:SystemRoot} + "\System32"
	$CommonDirs["HKLMSoftware32"] = "hklm:\Software\Wow6432Node"
	$CommonDirs["HKLMSoftware64"] = "hklm:\Software"
} else {
	$CommonDirs["ProgramFiles32"] = ${env:ProgramFiles}
	$CommonDirs["System32"] = ${env:SystemRoot} + "\System32"
	$CommonDirs["HKLMSoftware32"] = "hklm:\Software"
}
$CommonDirs["ProgramsApplications"] = $CommonDirs["Programs"] + "\Applications"
$CommonDirs["ProgramsUtilities"] = $CommonDirs["Programs"] + "\Utilities"


# **************************************************************************************************
# * job functions:
function niy { "Not implemented yet!"; $global:returncode = 1 }
function Run-Check {
	title "Check"

	$CheckResult = 0
	$CheckLoop = 0

	:checkloop foreach ($CurrentSetup in $Setup) {
		foreach ( $v in $SetupLoopVariables ) { Remove-Variable $v -ErrorAction SilentlyContinue }
		if ( $CurrentSetup.Architecture ) { if ( $CurrentSetup.Architecture -ne $OS["Architecture"] ) { continue checkloop } }
		$CheckLoop++
		switch ( Test-Setup -SetupDefinition $CurrentSetup ) {
			$true {}
			$false { $CheckResult++ }
			1024 {
				$global:errormessage = "Unknown check configuration at setup block no. ${CheckLoop}!"
				$global:returncode = 1024
				break checkloop
			}
			default {}
		}
	} # end of :checkloop
	$global:returncode = $CheckResult
	"RESULT: $CheckResult check(s) are failed."
	""
}
function Run-Install {
	title "Installation"

	:installloop foreach ($CurrentSetup in $Setup) {
		foreach ( $v in $SetupLoopVariables ) { Remove-Variable $v -ErrorAction SilentlyContinue }

		if ( $CurrentSetup.Architecture ) { if ( $CurrentSetup.Architecture -ne $OS["Architecture"] ) { continue installloop } }

		# prepare setup
		if ( "msi", "msp" -contains $CurrentSetup.Type.ToLower() ) {
			# MSI/MSP setup
			if ( ! $CurrentSetup.Name ) { continue }
			if ( ! $CurrentSetup.Path ) { $CurrentSetup.Path = $SourcePath; }
			$Command = $CommonDirs["System32_Current"] + "\msiexec.exe"
			$MSI = "`"" + $CurrentSetup.Path + "\" + $CurrentSetup.Name + "`""
			switch ($CurrentSetup.Type.ToLower()) {
				"msi" { $Parameters = @("/package") }
				"msp" { $Parameters = @("/update") }
			}
			$Parameters += @($MSI, [String]$OS["MSIExecDefaultParameters"])
			if ( $CurrentSetup.Transforms ) {
				$Parameters += "TRANSFORMS=" + "`"" + $CurrentSetup.Path + "\" + $CurrentSetup.Transforms + "`""
			}
			if ( $CurrentSetup.MSILogfile ) {
				# for compatibility
				$CurrentSetup.LogFile = $CurrentSetup.MSILogfile
			}
			if ( $CurrentSetup.LogFile ) {
				$Parameters += "/l*v " + "`"" + $CurrentSetup.LogFile + "`""
				if ( -not (Test-Path (split-path -parent $CurrentSetup.LogFile)) ) {
					New-Item -Path (split-path -parent $CurrentSetup.LogFile) -type directory -force | Out-Null
				}
			}
			if ( $CurrentSetup.Properties ) {
				$Parameters += $CurrentSetup.Properties
			}
			if ( $CurrentSetup.Features ) {
				$OFSbak = $OFS
				$OFS = ","
				$Parameters += "ADDLOCAL=" + $CurrentSetup.Features
				$OFS = $OFSbak
			}
		}
		elseif ( $CurrentSetup.Type.ToLower() -eq "msu" ) {
			# MSU update
			if ( ! $CurrentSetup.Name ) { continue }
			if ( ! $CurrentSetup.Path ) { $CurrentSetup.Path = $SourcePath; }
			$Command = $CommonDirs["System32_Current"] + "\wusa.exe"
			$MSU = "`"" + $CurrentSetup.Path + "\" + $CurrentSetup.Name + "`""
			$Parameters = @($MSU, "/quiet", "/norestart")
			if ( $CurrentSetup.LogFile ) {
				$Parameters += "/log:" + "`"" + $CurrentSetup.LogFile + "`""
				if ( -not (Test-Path (split-path -parent $CurrentSetup.LogFile)) ) {
					New-Item -Path (split-path -parent $CurrentSetup.LogFile) -type directory -force | Out-Null
				}
			}
		}
		elseif ( $CurrentSetup.Type.ToLower() -eq "ps" ) {
			# PS command
			if ( ! $CurrentSetup.Name ) { continue }
			$Command = $CurrentSetup.Name
			$Parameters = $CurrentSetup.Parameters
		}
		elseif ( $CurrentSetup.Type.ToLower() -eq "exe" ) {
			# executable setup
			if ( ! $CurrentSetup.Name ) { continue }
			if ( ! $CurrentSetup.Path ) { $CurrentSetup.Path = $SourcePath; }
			$Command = $CurrentSetup.Path + "\" + $CurrentSetup.Name
			$Parameters = $CurrentSetup.Parameters
		}
		elseif ( $CurrentSetup.Type.ToLower() -eq "reg" ) {
			# registry setting
			if ( ! $CurrentSetup.Path ) { continue }
			if ( ! $CurrentSetup.Value ) { continue }
			if ( ! $CurrentSetup.Data ) { continue }
			if ( ! $CurrentSetup.ValueType ) { $CurrentSetup.ValueType = "String" }
			$Path = $CurrentSetup.Path
			$Value = $CurrentSetup.Value
			$Data = $CurrentSetup.Data
			$ValueType = $CurrentSetup.ValueType
		}
		if ( -not $CurrentSetup.WindowStyle ) { $CurrentSetup.WindowStyle = "Normal" }

		# run setup
		if ( $Command ) {
			$CurrentExitCode = "1860"
			"Command: $Command $Parameters"
			if ( $CurrentSetup.Type.ToLower() -ne "ps") {
				if ($Parameters) {
		        	$CurrentExitCode = ( `
						Start-Process -Wait -WindowStyle $CurrentSetup.WindowStyle -Passthru `
							-FilePath "$Command" -ArgumentList "$Parameters" `
					).ExitCode
				} else {
					$CurrentExitCode = ( `
						Start-Process -Wait -WindowStyle $CurrentSetup.WindowStyle -Passthru `
							-FilePath "$Command" `
					).ExitCode
				}
			}
			else {
				Invoke-Expression -Command `
					"$Command -ErrorAction SilentlyContinue -ErrorVariable CurrentExitMessage $Parameters"
				if ( $CurrentExitMessage ) { $CurrentExitCode = 1 }
				else { $CurrentExitCode = 0 }
			}
	        "Exit code of last command: " + $CurrentExitCode
	        if ( $CurrentExitMessage ) { "Error message of last command: $CurrentExitMessage" }
			if ( $CurrentSetup.AcceptExitCodes -contains $CurrentExitCode ) {
				"This exit code ($CurrentExitCode) was expected so exit code 0 will be assumed."
				$CurrentExitCode = 0
			}
			switch ($CurrentExitCode) {
				"0" {
					"Last command was successful."
					break
				}
				"1604" {
					"Last command reported its already installed. This will be ignored."
					break
				}
				"3010" {
					"Last command requested a system reboot."
					"This will be signalized at end of package setup with exit code 3010."
					$global:Package["Reboot"] = $true
					break
				}
				default {
					$global:errormessage = "Last command exited with an error! Package setup will will canceled!"
					$global:returncode = $CurrentExitCode
					break installloop
				}
			}
		}
		elseif ( $CurrentSetup.Type.ToLower() -eq "reg" ) {
			"Registry: set value `"${Path}\${Value}=${Data}`" (${ValueType})"
			Set-RegistryValue -Path "$Path" -Value "$Value" -Data "$Data" -Type $ValueType
		}

		# setup ARP
		if ( $CurrentSetup.ARPID ) {
			"ARP: set `"$CurrentSetup.ARPID`""
			if ( $OS["Architecture"] -eq 'x64' `
					-and $OS["ArchitectureEnvironment"] -eq 'x64' `
					-and $CurrentSetup.ARPWow6432Node -eq $true ) {
				$ARPRegPath = $OS["HKLMSoftware32"]
			}
			else { $ARPRegPath = $OS["HKLMSoftware_Current"] }
			$ARPRegPath += "\Microsoft\Windows\CurrentVersion\Uninstall\" + $CurrentSetup.ARPID
			if ( $CurrentSetup.UninstallString ) {
				Set-RegistryValue `
					-Path "$ARPRegPath" -Value "UninstallString" `
					-Data $CurrentSetup.UninstallString -Type ExpandString
			}
			elseif ( -not (Get-RegistryValue -path "$ARPRegPath" -value "UninstallString") ) {
				Set-RegistryValue `
					-Path "$ARPRegPath" -Value "UninstallString" `
					-Data	"msg * `"A uninstallation via this function is not intended." + `
							"Ask your servicedesk or administrator how to do this.`"" `
					-Type ExpandString
				$CurrentSetup.ARPNoRemove = $true
				$CurrentSetup.ARPNoModify = $true
				$CurrentSetup.ARPNoRepair = $true
			}
			if ( $CurrentSetup.ARPName )
				{ Set-RegistryValue -Path "$ARPRegPath" -Value "DisplayName" -Data $CurrentSetup.ARPName }
			if ( $CurrentSetup.ARPName )
				{ Set-RegistryValue -Path "$ARPRegPath" -Value "DisplayName" -Data $CurrentSetup.ARPName }
			if ( $CurrentSetup.ARPVersion )
				{ Set-RegistryValue -Path "$ARPRegPath" -Value "DisplayVersion" -Data $CurrentSetup.ARPVersion }
			if ( $CurrentSetup.ARPIcon )
				{ Set-RegistryValue -Path "$ARPRegPath" -Value "DisplayIcon" -Data $CurrentSetup.ARPIcon }
			if ( $CurrentSetup.ARPContact )
				{ Set-RegistryValue -Path "$ARPRegPath" -Value "Contact" -Data $CurrentSetup.ARPContact }
			if ( $CurrentSetup.ARPComments )
				{ Set-RegistryValue -Path "$ARPRegPath" -Value "Comments" -Data $CurrentSetup.ARPComments }
			if ( $CurrentSetup.ARPHelpLink ) {
				Set-RegistryValue -Path "$ARPRegPath" -Value "HelpLink" -Data $CurrentSetup.ARPHelpLink -Type ExpandString
			}
			if ( $CurrentSetup.ARPHelpTelephone )
				{ Set-RegistryValue -Path "$ARPRegPath" -Value "HelpTelephone" -Data $CurrentSetup.ARPHelpTelephone }
			if ( $CurrentSetup.ARPNoModify -eq $true )
				{ Set-RegistryValue -Path "$ARPRegPath" -Value "NoModify" -Data 0x1 -Type DWord }
			else { Set-RegistryValue -Path "$ARPRegPath" -Value "NoModify" -Data 0x0 -Type DWord }
			if ( $CurrentSetup.ARPNoRemove -eq $true )
				{ Set-RegistryValue -Path "$ARPRegPath" -Value "NoRemove" -Data 0x1 -Type DWord }
			else { Set-RegistryValue -Path "$ARPRegPath" -Value "NoRemove" -Data 0x0 -Type DWord }
			if ( $CurrentSetup.ARPNoRepair -eq $true )
				{ Set-RegistryValue -Path "$ARPRegPath" -Value "NoRepair" -Data 0x1 -Type DWord }
			else { Set-RegistryValue -Path "$ARPRegPath" -Value "NoRepair" -Data 0x0 -Type DWord }
			if ( $CurrentSetup.ARPSystemComponent -eq $true )
				{ Set-RegistryValue -Path "$ARPRegPath" -Value "SystemComponent" -Data 0x1 -Type DWord }
			else { Set-RegistryValue -Path "$ARPRegPath" -Value "SystemComponent" -Data 0x0 -Type DWord }
			if ( $CurrentSetup.RemoveARPURLUpdateInfo -eq $true ) {
				Remove-RegistryValue -Path "$ARPRegPath" -Value "URLUpdateInfo"
			}
		} # end of setup ARP
	} # end of :installloop
	""
}
function Run-Uninstall {
	title "Uninstallation"

	[array]::Reverse($Setup)
	:removeloop foreach ($CurrentSetup in $Setup) {
		foreach ( $v in $SetupLoopVariables ) { Remove-Variable $v -ErrorAction SilentlyContinue }

		if ( $CurrentSetup.Architecture ) { if ( $CurrentSetup.Architecture -ne $OS["Architecture"] ) { continue removeloop } }

		# prepare setup
		if ( $CurrentSetup.Type.ToLower() -eq "msi" ) {
			# MSI setup
			if ( ! $CurrentSetup.GUID ) { continue }
			$Command = $CommonDirs["System32_Current"] + "\msiexec.exe"
			$GUID = "`"" + $CurrentSetup.GUID + "`""
			$Parameters = @("/uninstall", $GUID, [String]$OS["MSIExecDefaultParameters"])
			if ( $CurrentSetup.MSILogfile ) {
				# for compatibility
				$CurrentSetup.LogFile = $CurrentSetup.MSILogfile
			}
			if ( $CurrentSetup.LogFile ) {
				$Parameters += "/l*v " + "`"" + $CurrentSetup.LogFile + "`""
				if ( -not (Test-Path (split-path -parent $CurrentSetup.LogFile)) ) {
					New-Item -Path (split-path -parent $CurrentSetup.LogFile) -type directory -force | Out-Null
				}
			}
			if ( $CurrentSetup.Properties ) {
				$Parameters += $CurrentSetup.Properties
			}
			if ( $CurrentSetup.Features ) {
				$OFSbak = $OFS
				$OFS = ","
				$Parameters += "REMOVE=" + $CurrentSetup.Features
				$OFS = $OFSbak
			}
			else {
				$Parameters += "REMOVE=ALL"
			}
		}
		elseif ( $CurrentSetup.Type.ToLower() -eq "msp" ) { continue }
		elseif ( $CurrentSetup.Type.ToLower() -eq "msu" ) {
			# MSU update
			if ( $CurrentSetup.DontRemove ) { continue }
			if ( -not $CurrentSetup.Name ) { continue }
			if ( -not $CurrentSetup.Path ) { $CurrentSetup.Path = $SourcePath; }
			$Command = $CommonDirs["System32_Current"] + "\wusa.exe"
			$MSU = "`"" + $CurrentSetup.Path + "\" + $CurrentSetup.Name + "`""
			$Parameters = @("/uninstall", $MSU, "/quiet", "/norestart")
			if ( $CurrentSetup.LogFile ) {
				$Parameters += "/log:" + "`"" + $CurrentSetup.LogFile + "`""
				if ( -not (Test-Path (split-path -parent $CurrentSetup.LogFile)) ) {
					New-Item -Path (split-path -parent $CurrentSetup.LogFile) -type directory -force | Out-Null
				}
			}
		}
		elseif ( $CurrentSetup.Type.ToLower() -eq "ps" ) {
			# PS command
			if ( ! $CurrentSetup.UninstallName ) { continue }
			$Command = $CurrentSetup.UninstallName
			$Parameters = $CurrentSetup.UninstallParameters
		}
		elseif ( $CurrentSetup.Type.ToLower() -eq "exe" ) {
			# executable setup
			if ( ! $CurrentSetup.UninstallName ) { continue }
			if ( ! $CurrentSetup.UninstallPath ) { $CurrentSetup.UninstallPath = $SourcePath; }
			$Command = $CurrentSetup.UninstallPath + "\" + $CurrentSetup.UninstallName
			$Parameters = $CurrentSetup.UninstallParameters
		}
		elseif ( $CurrentSetup.Type.ToLower() -eq "reg" ) {
			# registry setting
			if ( ! $CurrentSetup.Path ) { continue }
			if ( ! $CurrentSetup.Value ) { continue }
			$Path = $CurrentSetup.Path
			$Value = $CurrentSetup.Value
		}
		if ( -not $CurrentSetup.WindowStyle ) { $CurrentSetup.WindowStyle = "Normal" }

		# run setup
		if ( $Command ) {
			$CurrentExitCode = "1860"
			"Command: $Command $Parameters"
	        if ( $CurrentSetup.Type.ToLower() -ne "ps") {
				if ($Parameters) {
		        	$CurrentExitCode = ( `
						Start-Process -Wait -WindowStyle $CurrentSetup.WindowStyle -Passthru `
							-FilePath "$Command" -ArgumentList "$Parameters" `
					).ExitCode
				} else {
					$CurrentExitCode = ( `
						Start-Process -Wait -WindowStyle $CurrentSetup.WindowStyle -Passthru `
							-FilePath "$Command" `
						).ExitCode
				}
			}
			else {
				Invoke-Expression `
					-Command "$Command -ErrorAction SilentlyContinue -ErrorVariable CurrentExitMessage $Parameters"
				if ( $CurrentExitMessage ) { $CurrentExitCode = 1 }
				else { $CurrentExitCode = 0 }
			}
	        "Exit code of last command: " + $CurrentExitCode
	        if ( $CurrentExitMessage ) { "Error message of last command: $CurrentExitMessage" }
			if ( $CurrentSetup.UninstallAcceptExitCodes -contains $CurrentExitCode ) {
				"This exit code ($CurrentExitCode) was expected so exit code 0 will be assumed."
				$CurrentExitCode = 0
			}
	        switch ($CurrentExitCode) {
				"0" {
					"Last command was successful."
					break
				}
				"1605" {
					"Last command reported its NOT installed. This will be ignored."
					break
				}
				"3010" {
					"Last command requested a system reboot."
					"This will be signalized at end of package setup with exit code 3010."
					$global:Package["Reboot"] = $true
					break
				}
				default {
					$global:errormessage = "Last command exited with an error! Package setup will will canceled!"
					$global:returncode = $CurrentExitCode
					break removeloop
				}
	        }
		}
		elseif ( $CurrentSetup.Type.ToLower() -eq "reg" ) {
			"Registry: remove value `"${Path}\${Value}`""
			Remove-RegistryValue -Path "$Path" -Value "$Value"
			if ( -not (get-itemproperty "$Path" -ErrorAction SilentlyContinue) `
					-and -not (get-childitem "$Path" -ErrorAction SilentlyContinue)) {
				"Registry: remove Path `"$Path`""
				Remove-Item "$Path" -ErrorAction SilentlyContinue | Out-Null
			}
		}

		# remove ARP
        if ( $CurrentSetup.ARPID -and $CurrentSetup.UninstallARP -eq $true ) {
			"ARP: remove `"$CurrentSetup.ARPID`""
			if ( $OS["Architecture"] -eq 'x64' `
					-and $OS["ArchitectureEnvironment"] -eq 'x64' `
					-and $CurrentSetup.ARPWow6432Node -eq $true ) {
				$ARPRegPath = $OS["HKLMSoftware32"]
			}
			else { $ARPRegPath = $OS["HKLMSoftware_Current"] }
			$ARPRegPath += "\Microsoft\Windows\CurrentVersion\Uninstall\" + $CurrentSetup.ARPID
			Remove-Item "$ARPRegPath" -recurse -force -ErrorAction SilentlyContinue
        } # end of remove ARP
	} # end of :removeloop
	""
}
function Write-Configuration {
	title "Configuration"
	"===== Global variables and constants ====="; ""
	"Action = $Action"
	"ConfirmPreference = $ConfirmPreference"
	"ErrorActionPreference = $ErrorActionPreference"
	"LogFile = $LogFile"
	"Parameters = " + [String]$Parameters
	"SourcePath = $SourcePath"
	"ScriptName = $ScriptName"
	"VERSION (of script) = $VERSION"
	""
	"===== Hash `$Package =====";
	$Package.GetEnumerator() | sort name | Format-Table;
	"===== Hash `$Organization =====";
	$Organization.GetEnumerator() | sort name | Format-Table;
	"===== Hash `$OS =====";
	$OS.GetEnumerator() | sort name | Format-Table;
	"===== Hash `$CommonDirs =====";
	$CommonDirs.GetEnumerator() | sort name | Format-Table;
	"===== Hash `$Setup =====";
	foreach ($CurrentSetup in $Setup) {
		$CurrentSetup.GetEnumerator() | sort name | Format-Table;
	}
}
function Write-Help {
	title "Usage"
	"$ScriptName { install | remove | check | reinstall* | repair* } [-f]* [-l LogFile]*"
	"$ScriptName { info | summary* | help }"
	"$ScriptName exportxml Output-Filename"
	"(* not implemented yet)"
	""
	"check:     Test if deployment was successful."
	"           Resulting exit code will be the count of failed setup"
	"           actions. If exit code is 1024 a script error occurred."
	"exportxml: Exports package configuration to an XML file."
	"help:      Shows this help."
	"info:      Shows package informations and script configuration."
	"install:   Installs this package to the system."
	"remove:    Removes this package from the system."
}
function Write-DeploymentResultMessages {
	if ($global:returncode -eq 0) {
		"RESULT: Deployment of `"" + [String]$Package["Vendor","Product","Version","Architecture"] + "`" was successful."
		if ($global:Package["Reboot"] -eq $true) {
			"But a restart of the system is neccessary to complete installation!"
			$global:returncode = 3010
		}
	}
	else {
		"RESULT: Deployment of `"" + [String]$Package["Vendor","Product","Version","Architecture"] + "`" was NOT successful!"
	}
}
function Write-XML {
	param (
		[Parameter(Mandatory=$true)][String]$Path
	)
	title "Export XML"
	if ( ! $Path ) {
		$global:errormessage = "Missing file argument for XML output!"
		$global:returncode = 1
		return
	}
	Export-Clixml -Path $Path -InputObject @{
		Package = $global:Package;
		Organization = $global:Organization;
		OS = @{
			LogFile = $global:OS["LogFile"];
			MSIExecDefaultParameters = $global:OS["MSIExecDefaultParameters"];
		};
		Setup = $global:Setup;
	}
	"Package configuration exported to '" + (Resolve-Path -Path $Path).Path + "'."
}


# **************************************************************************************************
# * main:
hr
$Organization["Name"] + " - Deployment Setup Script - Version ${VERSION}"
"Unattended Setup of `"" + [String]$Package["Vendor","Product","Version","Architecture"] + "`""

$global:returncode = 0
$Action, $Parameters = $args;
if ( -not $Action) { $Action = 'none' }
Set-Location "$SourcePath"
Get-SetupJobs

switch -regex ($Action.ToLower()) {
	"^install$"				{ Run-Install; Write-DeploymentResultMessages }
	"^(remove|uninstall)$"	{ Run-Uninstall; Write-DeploymentResultMessages }
	"^check$"				{ Run-Check; Write-DeploymentResultMessages }
	"^reinstall$"			{ niy }
	"^repair$"				{ niy }
	"^info$"				{ Write-Configuration }
	"^summary$"				{ niy }
	"^(help|--help|-help|-h|-\?|\/\?|\?)$"	{ Write-Help }
	"^exportxml$" {
		if ( $Parameters -and ($Parameters.GetType().Name -eq "String") ) {
			Write-XML -Path $Parameters
		}
		else {
			$global:errormessage = "Missing or wrong file argument for XML output!"
			$global:returncode = 1
		}
	}
	default	{
		Write-Help
		$global:errormessage = "Missing or wrong arguments! See documentation and usage above."
		$global:returncode = 1
	}
}
# **************************************************************************************************
# * closing:
title "End"
if ($global:returncode -ne 0) {
	if ($global:errormessage) { "ERROR: " + $global:errormessage }
	elseif (-not $Action.ToLower() -eq "check") { "An error occurred!" }
	"Exit code: $global:returncode"
}
""
if ( $LogFile ) { Stop-Transcript }
exit $global:returncode
# **************************************************************************************************
# END
